package http

import (
	"crypto/tls"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/wavynote/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/wavynote/internal/gateway/http/handler/restapi"
	"github.com/wavynote/internal/gateway/http/handler/restapi/box"
	"github.com/wavynote/internal/gateway/http/handler/restapi/root"
	"github.com/wavynote/internal/gateway/http/handler/restapi/search"
	"github.com/wavynote/internal/gateway/http/handler/restapi/write"

	swaggofiles "github.com/swaggo/files"
	ginswagger "github.com/swaggo/gin-swagger"
)

// for swagger description
const (
	SWAGGER_DESC_REQUIREMENT = `
		<h2>요구 사항</h2>
		Wavynote에서 제공하는 REST API는 SSL(Secure Sockets Layer)이 적용된 HTTPS 프로토콜로만 호출이 가능합니다.
	`

	SWAGGER_DESC_REQUEST = `
		<h2>요청</h2>
		Wavynote에서 제공하는 REST API 요청 규격을 구성하는 요소는 아래와 같습니다.
		<ul>
			<li><b>메서드(Method)</b>: API 호출 시 사용해야할 HTTP 요청 메서드</li>
			<li><b>IP 주소</b>: Wavynote 백엔드 모듈이 구동 중인 서버의 IP 주소</li>
			<li><b>포트 번호</b>: Wavynote 백엔드 모듈이 열고 있는 REST API용 HTTPS 서버 포트(기본값:16770)</li>
			<li><b>URL</b>: API를 통해 제공되는 리소스마다 지정된 요청 경로로 IP주소:PORT와 함께 각 API의 엔드포인트를 구성함. <mark>반드시 Base URL(<b>/wavynote/v1.0</b>)을 추가</mark>해주어야 함 (예시: /wavynote/v1.0/main/folderlist)</li>
			<li><b>헤더(Header)</b>: API 호출 시 필요한 인증 정보(현재는 Basic Authentication 방식만을 제공함)를 전달하는데 사용 (예시: Authorization: Basic {ID:PW Base64 인코딩 데이터})</li>
			<li><b>경로 변수(Path variable)</b>: API 호출 시 사용자가 전달한 값을 포함해 URL을 구성할 때 사용 (예시: /wavynote/v1.0/write/send)</li>
		</ul>
		각 API별 요청 규격이 상이하므로 상세 정보를 확인하고 호출해야 합니다.
	`

	SWAGGER_DESC_RESPONSE = `
		<h2>응답</h2>
		Wavynote에서 제공하는 REST API 요청에 대한 응답 데이터는 각각의 API 항목을 탭하여 확인할 수 있습니다.
	`

	SWAGGER_DESC_HOW_TO_TEST = `
		<h2>테스트 방법</h2>
		<ol>
			<li>아래 <b><font color="#49BF88">Authorize</font></b> 버튼을 클릭하여 Basic Authentication을 위한 Username과 Password를 입력합니다. (해당 과정에서 입력 값에 대한 유효성 여부를 체크하지는 않음)</li>
			<li>테스트할 API 항목을 탭하면 <b>Try it out</b> 버튼이 나타나며, 해당 버튼을 클릭하면 (파라미터가 존재하는 요청이라면 파라미터 입력 창이 활성화되고) <b><font color="#4B94F2">Execute</font></b> 버튼이 나타납니다.</li>
			<li>샘플 데이터를 참고하여 테스트 API에 대한 파라미터 정보를 입력한 뒤 <b><font color="#4B94F2">Execute</font></b> 버튼을 클릭하면 해당 요청이 서버로 전송되며 이에 대한 응답 값을 확인할 수 있습니다.</li>
			<li>추가적으로 해당 요청에 대한 curl 명령어 구문과 URL 데이터 또한 확인할 수 있습니다.</li>
		</ol>
	`
)

type HTTPServer struct {
	ip       string
	port     int
	cert     string
	pkey     string
	rtimeout int
	wtimeout int
}

func NewHTTPServer(ip string, port int, cert string, pkey string, rtimeout int, wtimeout int) *HTTPServer {
	httpServer := &HTTPServer{
		ip:       ip,
		port:     port,
		cert:     cert,
		pkey:     pkey,
		rtimeout: rtimeout,
		wtimeout: wtimeout,
	}
	return httpServer
}

// @contact.name   wavynote
// @contact.email  chelseafandev@gmail.com

// @securityDefinitions.basic 	BasicAuth
func (h *HTTPServer) StartServer() {
	connInfo := ":" + strconv.Itoa(h.port)

	// https://wiki.mozilla.org/Security/Server_Side_TLS
	//
	// not supported in go
	//  0x00,0x9E - DHE-RSA-AES128-GCM-SHA256
	//  0x00,0x9F - DHE-RSA-AES256-GCM-SHA384
	tlsCfg := &tls.Config{
		MinVersion:       tls.VersionTLS12,
		CurvePreferences: []tls.CurveID{tls.X25519, tls.CurveP256, tls.CurveP384},
		CipherSuites: []uint16{
			tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
			tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
			tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
			tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
			tls.TLS_AES_128_GCM_SHA256,
			tls.TLS_AES_256_GCM_SHA384,
			tls.TLS_CHACHA20_POLY1305_SHA256,
		},
	}

	router := gin.Default()

	// setup swagger
	//  - 테스트 방식에 대한 설명 추가
	//  - 카테고리 구분에 대한 설명 추가
	docs.SwaggerInfo.Title = "Wavynote REST API"
	desc := SWAGGER_DESC_REQUIREMENT + SWAGGER_DESC_REQUEST + SWAGGER_DESC_RESPONSE + SWAGGER_DESC_HOW_TO_TEST
	desc = strings.ReplaceAll(desc, "\n", "")
	desc = strings.ReplaceAll(desc, "\t", "")
	docs.SwaggerInfo.Description = desc
	docs.SwaggerInfo.Version = restapi.RESTAPI_VERSION
	docs.SwaggerInfo.BasePath = restapi.RESTAPI_BASEPATH
	docs.SwaggerInfo.Schemes = []string{"https"}

	router.GET("/", func(c *gin.Context) {
		c.Redirect(http.StatusTemporaryRedirect, "/swagger/index.html")
	})
	router.GET("/swagger/*any", ginswagger.WrapHandler(swaggofiles.Handler))

	// NoRoute(404 Not Found)
	router.NoRoute(func(c *gin.Context) {
		c.IndentedJSON(
			http.StatusNotFound, restapi.Response404{
				Code: http.StatusNotFound,
				Msg:  fmt.Sprintf("%d %s no route", http.StatusNotFound, http.StatusText(http.StatusNotFound)),
			})
	})

	api := router.Group(restapi.RESTAPI_BASEPATH)
	{
		m := api.Group(restapi.RESTAPI_SERVICENAME_MAIN)
		{
			m.GET(
				restapi.LOCATION_FOR_MAIN_FOLDERLIST,
				root.NewRootHandler().GetFolderList,
			)

			m.GET(
				restapi.LOCATION_FOR_MAIN_NOTELIST,
				root.NewRootHandler().GetNoteList,
			)

			m.POST(
				restapi.LOCATION_FOR_MAIN_FOLDER,
				root.NewRootHandler().ChangeFolderName,
			)

			m.DELETE(
				restapi.LOCATION_FOR_MAIN_FOLDER,
				root.NewRootHandler().RemoveFolder,
			)

			m.DELETE(
				restapi.LOCATION_FOR_MAIN_NOTE,
				root.NewRootHandler().RemoveNote,
			)
		}

		w := api.Group(restapi.RESTAPI_SERVICENAME_WRITE)
		{
			w.POST(
				restapi.LOCATION_FOR_WRITE_SAVE,
				write.NewWriteHandler().SaveNote,
			)

			w.POST(
				restapi.LOCATION_FOR_WRITE_SEND,
				write.NewWriteHandler().SendNote,
			)

			w.POST(
				restapi.LOCATION_FOR_WRITE_OPENNOTE,
				write.NewWriteHandler().ShareToOpenNote,
			)

			w.POST(
				restapi.LOCATION_FOR_WRITE_RANDOM,
				write.NewWriteHandler().SendNoteToRandomUser,
			)

			w.GET(
				restapi.LOCATION_FOR_WRITE_SHOW,
				write.NewWriteHandler().ShowNote,
			)
		}

		s := api.Group(restapi.RESTAPI_SERVICENAME_SEARCH)
		{
			s.GET(
				restapi.LOCATION_FOR_SEARCH_FROM_TOP,
				search.NewSearchHandler().SearchNoteFromTop,
			)

			s.GET(
				restapi.LOCATION_FOR_SEARCH_FROM_FOLDER,
				search.NewSearchHandler().SearchNoteFromTargetFolder,
			)
		}

		b := api.Group(restapi.RESTAPI_SERVICENAME_BOX)
		{
			b.GET(
				restapi.LOCATION_FOR_BOX_CONVERSATION_LIST,
				box.NewBoxHandler().ShowConversation,
			)

			b.GET(
				restapi.LOCATION_FOR_BOX_NOTELIST,
				box.NewBoxHandler().ShowConversationNoteList,
			)

			b.GET(
				restapi.LOCATION_FOR_BOX_SHOW,
				box.NewBoxHandler().ShowConversationNote,
			)

			b.DELETE(
				restapi.LOCATION_FOR_BOX_CONVERSATION,
				box.NewBoxHandler().DeleteConversation,
			)
		}

		// p := api.Group(restapi.RESTAPI_SERVICENAME_PROFILE)
		// {

		// }
	}

	tlsSrv := &http.Server{
		Addr:         connInfo,
		TLSConfig:    tlsCfg,
		Handler:      router,
		TLSNextProto: make(map[string]func(*http.Server, *tls.Conn, http.Handler), 0), // disable HTTP2
		ReadTimeout:  time.Duration(h.rtimeout) * time.Second,
		WriteTimeout: time.Duration(h.wtimeout) * time.Second,
	}

	err := tlsSrv.ListenAndServeTLS(h.cert, h.pkey)
	if err != nil {
		return
	}
}
