package http

import (
	"crypto/tls"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/wavynote/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/wavynote/internal/gateway/http/handler/restapi"
	"github.com/wavynote/internal/gateway/http/handler/restapi/box"
	"github.com/wavynote/internal/gateway/http/handler/restapi/opennote"
	"github.com/wavynote/internal/gateway/http/handler/restapi/profile"
	"github.com/wavynote/internal/gateway/http/handler/restapi/root"
	"github.com/wavynote/internal/gateway/http/handler/restapi/search"
	"github.com/wavynote/internal/gateway/http/handler/restapi/write"
	"github.com/wavynote/internal/wavynote"

	swaggofiles "github.com/swaggo/files"
	ginswagger "github.com/swaggo/gin-swagger"
)

// for swagger description
const (
	SWAGGER_DESC_REQUIREMENT = `
		<h2>요구 사항</h2>
		Wavynote에서 제공하는 REST API는 SSL(Secure Sockets Layer)이 적용된 HTTPS 프로토콜로만 호출이 가능합니다.
	`

	SWAGGER_DESC_REQUEST = `
		<h2>요청</h2>
		Wavynote에서 제공하는 REST API 요청 규격을 구성하는 요소는 아래와 같습니다.
		<ul>
			<li><b>메서드(Method)</b>: API 호출 시 사용해야할 HTTP 요청 메서드</li>
			<li><b>IP 주소</b>: Wavynote 백엔드 모듈이 구동 중인 서버의 IP 주소</li>
			<li><b>포트 번호</b>: Wavynote 백엔드 모듈이 열고 있는 REST API용 HTTPS 서버 포트(기본값:16770)</li>
			<li><b>URL</b>: API를 통해 제공되는 리소스마다 지정된 요청 경로로 IP주소:PORT와 함께 각 API의 엔드포인트를 구성함. <mark>반드시 Base URL(<b>/wavynote/v1.0</b>)을 추가</mark>해주어야 함 (예시: /wavynote/v1.0/main/folderlist)</li>
			<li><b>헤더(Header)</b>: API 호출 시 필요한 인증 정보(현재는 Basic Authentication 방식만을 제공함)를 전달하는데 사용 (예시: Authorization: Basic {ID:PW Base64 인코딩 데이터})</li>
			<li><b>경로 변수(Path variable)</b>: API 호출 시 사용자가 전달한 값을 포함해 URL을 구성할 때 사용 (예시: /wavynote/v1.0/write/send)</li>
		</ul>
		각 API별 요청 규격이 상이하므로 상세 정보를 확인하고 호출해야 합니다.
	`

	SWAGGER_DESC_RESPONSE = `
		<h2>응답</h2>
		Wavynote에서 제공하는 REST API 요청에 대한 응답 데이터는 각각의 API 항목을 탭하여 확인할 수 있습니다.
	`

	SWAGGER_DESC_HOW_TO_TEST = `
		<h2>테스트 방법</h2>
		<ol>
			<li>아래 <b><font color="#49BF88">Authorize</font></b> 버튼을 클릭하여 Basic Authentication을 위한 Username과 Password를 입력합니다. (해당 과정에서 입력 값에 대한 유효성 여부를 체크하지는 않음)</li>
			<li>테스트할 API 항목을 탭하면 <b>Try it out</b> 버튼이 나타나며, 해당 버튼을 클릭하면 (파라미터가 존재하는 요청이라면 파라미터 입력 창이 활성화되고) <b><font color="#4B94F2">Execute</font></b> 버튼이 나타납니다.</li>
			<li>샘플 데이터를 참고하여 테스트 API에 대한 파라미터 정보를 입력한 뒤 <b><font color="#4B94F2">Execute</font></b> 버튼을 클릭하면 해당 요청이 서버로 전송되며 이에 대한 응답 값을 확인할 수 있습니다.</li>
			<li>추가적으로 해당 요청에 대한 curl 명령어 구문과 URL 데이터 또한 확인할 수 있습니다.</li>
		</ol>
	`
)

type HTTPServer struct {
	httpInfo wavynote.HTTPServerInfo
	dbInfo   wavynote.DataBaseInfo
}

func NewHTTPServer(httpInfo wavynote.HTTPServerInfo, dbInfo wavynote.DataBaseInfo) *HTTPServer {
	httpServer := &HTTPServer{
		httpInfo: httpInfo,
		dbInfo:   dbInfo,
	}
	return httpServer
}

// @contact.name   wavynote
// @contact.email  chelseafandev@gmail.com

// @securityDefinitions.basic 	BasicAuth
func (h *HTTPServer) StartServer() {
	connInfo := ":" + strconv.Itoa(h.httpInfo.Port)

	// https://wiki.mozilla.org/Security/Server_Side_TLS
	//
	// not supported in go
	//  0x00,0x9E - DHE-RSA-AES128-GCM-SHA256
	//  0x00,0x9F - DHE-RSA-AES256-GCM-SHA384
	tlsCfg := &tls.Config{
		MinVersion:       tls.VersionTLS12,
		CurvePreferences: []tls.CurveID{tls.X25519, tls.CurveP256, tls.CurveP384},
		CipherSuites: []uint16{
			tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
			tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
			tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
			tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
			tls.TLS_AES_128_GCM_SHA256,
			tls.TLS_AES_256_GCM_SHA384,
			tls.TLS_CHACHA20_POLY1305_SHA256,
		},
	}

	router := gin.Default()

	// setup swagger
	//  - 테스트 방식에 대한 설명 추가
	//  - 카테고리 구분에 대한 설명 추가
	docs.SwaggerInfo.Title = "Wavynote REST API"
	desc := SWAGGER_DESC_REQUIREMENT + SWAGGER_DESC_REQUEST + SWAGGER_DESC_RESPONSE + SWAGGER_DESC_HOW_TO_TEST
	desc = strings.ReplaceAll(desc, "\n", "")
	desc = strings.ReplaceAll(desc, "\t", "")
	docs.SwaggerInfo.Description = desc
	docs.SwaggerInfo.Version = restapi.RESTAPI_VERSION
	docs.SwaggerInfo.BasePath = restapi.RESTAPI_BASEPATH
	docs.SwaggerInfo.Schemes = []string{"https"}

	router.GET("/", func(c *gin.Context) {
		c.Redirect(http.StatusTemporaryRedirect, "/swagger/index.html")
	})
	router.GET("/swagger/*any", ginswagger.WrapHandler(swaggofiles.Handler))

	// NoRoute(404 Not Found)
	router.NoRoute(func(c *gin.Context) {
		c.IndentedJSON(
			http.StatusNotFound, restapi.Response404{
				Code: http.StatusNotFound,
				Msg:  fmt.Sprintf("%d %s no route", http.StatusNotFound, http.StatusText(http.StatusNotFound)),
			})
	})

	api := router.Group(restapi.RESTAPI_BASEPATH)
	{
		m := api.Group(restapi.RESTAPI_SERVICENAME_MAIN)
		{
			m.GET(
				restapi.LOCATION_FOR_MAIN_FOLDERLIST,
				restapi.BasicAuth,
				root.NewRootHandler(h.dbInfo).GetFolderList,
			)

			m.GET(
				restapi.LOCATION_FOR_MAIN_NOTELIST,
				restapi.BasicAuth,
				root.NewRootHandler(h.dbInfo).GetNoteList,
			)

			m.PUT(
				restapi.LOCATION_FOR_MAIN_NOTEFOLDER,
				restapi.BasicAuth,
				root.NewRootHandler(h.dbInfo).ChangeNoteFolder,
			)

			m.POST(
				restapi.LOCATION_FOR_MAIN_FOLDER,
				restapi.BasicAuth,
				root.NewRootHandler(h.dbInfo).AddFolder,
			)

			m.PUT(
				restapi.LOCATION_FOR_MAIN_FOLDER,
				restapi.BasicAuth,
				root.NewRootHandler(h.dbInfo).ChangeFolderName,
			)

			m.DELETE(
				restapi.LOCATION_FOR_MAIN_FOLDER,
				restapi.BasicAuth,
				root.NewRootHandler(h.dbInfo).RemoveFolder,
			)

			m.DELETE(
				restapi.LOCATION_FOR_MAIN_NOTE,
				restapi.BasicAuth,
				root.NewRootHandler(h.dbInfo).RemoveNote,
			)
		}

		w := api.Group(restapi.RESTAPI_SERVICENAME_WRITE)
		{
			w.POST(
				restapi.LOCATION_FOR_WRITE_SAVE,
				restapi.BasicAuth,
				write.NewWriteHandler(h.dbInfo).SaveNote,
			)

			w.PUT(
				restapi.LOCATION_FOR_WRITE_SAVE,
				restapi.BasicAuth,
				write.NewWriteHandler(h.dbInfo).UpdateNote,
			)

			w.POST(
				restapi.LOCATION_FOR_WRITE_SEND,
				restapi.BasicAuth,
				write.NewWriteHandler(h.dbInfo).SendNote,
			)

			w.POST(
				restapi.LOCATION_FOR_WRITE_OPENNOTE,
				restapi.BasicAuth,
				write.NewWriteHandler(h.dbInfo).ShareToOpenNote,
			)

			w.POST(
				restapi.LOCATION_FOR_WRITE_RANDOM,
				restapi.BasicAuth,
				write.NewWriteHandler(h.dbInfo).SendNoteToRandomUser,
			)

			w.GET(
				restapi.LOCATION_FOR_WRITE_SHOW,
				restapi.BasicAuth,
				write.NewWriteHandler(h.dbInfo).ShowNote,
			)
		}

		s := api.Group(restapi.RESTAPI_SERVICENAME_SEARCH)
		{
			s.GET(
				restapi.LOCATION_FOR_SEARCH_FROM_TOP,
				restapi.BasicAuth,
				search.NewSearchHandler(h.dbInfo).SearchNoteFromTop,
			)

			s.GET(
				restapi.LOCATION_FOR_SEARCH_FROM_FOLDER,
				restapi.BasicAuth,
				search.NewSearchHandler(h.dbInfo).SearchNoteFromTargetFolder,
			)

			s.GET(
				restapi.LOCATION_FOR_SEARCH_FROM_OPENNOTE,
				restapi.BasicAuth,
				search.NewSearchHandler(h.dbInfo).SearchOpenNote,
			)
		}

		b := api.Group(restapi.RESTAPI_SERVICENAME_BOX)
		{
			b.GET(
				restapi.LOCATION_FOR_BOX_CONVERSATION_LIST,
				restapi.BasicAuth,
				box.NewBoxHandler(h.dbInfo).ShowConversation,
			)

			b.GET(
				restapi.LOCATION_FOR_BOX_NOTELIST,
				restapi.BasicAuth,
				box.NewBoxHandler(h.dbInfo).ShowConversationNoteList,
			)

			b.GET(
				restapi.LOCATION_FOR_BOX_SHOW,
				restapi.BasicAuth,
				box.NewBoxHandler(h.dbInfo).ShowConversationNote,
			)

			b.DELETE(
				restapi.LOCATION_FOR_BOX_CONVERSATION,
				restapi.BasicAuth,
				box.NewBoxHandler(h.dbInfo).DeleteConversation,
			)
		}

		p := api.Group(restapi.RESTAPI_SERVICENAME_PROFILE)
		{
			p.POST(
				restapi.LOCATION_FOR_PROFILE_SIGNIN,
				restapi.BasicAuth,
				profile.NewProfileHandler(h.dbInfo).SignIn,
			)

			p.GET(
				restapi.LOCATION_FOR_PROFILE_CHECKDULPLICATEID,
				restapi.BasicAuth,
				profile.NewProfileHandler(h.dbInfo).CheckDuplicateID,
			)

			p.POST(
				restapi.LOCATION_FOR_PROFILE_SIGNUP,
				restapi.BasicAuth,
				profile.NewProfileHandler(h.dbInfo).SignUp,
			)
		}

		o := api.Group(restapi.RESTAPI_SERVICENAME_OPENNOTE)
		{
			o.GET(
				restapi.LOCATION_FOR_OPENNOTE_LIST,
				restapi.BasicAuth,
				opennote.NewOpenNotehHandler(h.dbInfo).GetOpenNoteList,
			)

			o.GET(
				restapi.LOCATION_FOR_OPENNOTE_SHOW,
				restapi.BasicAuth,
				opennote.NewOpenNotehHandler(h.dbInfo).ShowOpenNote,
			)
		}
	}

	tlsSrv := &http.Server{
		Addr:         connInfo,
		TLSConfig:    tlsCfg,
		Handler:      router,
		TLSNextProto: make(map[string]func(*http.Server, *tls.Conn, http.Handler), 0), // disable HTTP2
		ReadTimeout:  time.Duration(h.httpInfo.Rtimeout) * time.Second,
		WriteTimeout: time.Duration(h.httpInfo.Wtimeout) * time.Second,
	}

	err := tlsSrv.ListenAndServeTLS(h.httpInfo.Cert, h.httpInfo.Pkey)
	if err != nil {
		return
	}
}
